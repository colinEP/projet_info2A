#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <strings.h>

#include <global.h>
#include <notify.h>
#include <lex.h>
#include <queue_list.h>
#include <test.h>

#include <etiq.h>

#include <error.h>



LIST build_list_etiq( LIST list_lex ) {
    LIST tab_etiq = new_list();

    LEXEM lex;
    ETIQ etiq = calloc(1, sizeof(*etiq));   //calloc ??????????

    // TODO compteur de décalage

    // TODO verif si etiq pas déjà definie OU ecraser si deja definie

    LIST l;
    for ( l=list_lex ; l!=NULL ; l=l->next ) {
        lex = (LEXEM) l->element;
        if ( lex->lex_type==SYMBOLE) {
            if (l->next!=NULL) {  // normalement il aura toujours un \n à la fin,
                                  // mais on sait jamais (si on ne rajoute plus le \n à la fin de chaque ligne)
                if ( ((LEXEM) l->next->element)->lex_type==DEUX_PTS) {
                    // ajoute à tab_etiq
                    printf("%d   %s\n", lex->nline, lex->value);
                    etiq->name = strdup(lex->value);   //strdup ou ne pas free 2x
                    etiq->nline = lex->nline;
                    // add_head ou add_end   (ETIQ)
                }
            }
            else ;// probleme
        }
    }

    return tab_etiq;
}

enum {NONE, TEXT, DATA, BSS}

void section_counter( LIST curr_list_lex , int curr_section, int* decal_line, int* text_counter, int* data_counter, int* bss_counter ) {

    if // .text
    else if
    else if
    else
        if // no comm
        if // no none

    if // \n
        if // prochain est symbole
            if // prochain n'est pas DEUX_PTS
                counter++
        if // DIRETIVE

    LEXEM curr_lex = (LEXEM) curr_list_lex->element;

    if      ( strcmp( curr_lex->value , ".text") ) return TEXT;
    else if ( strcmp( curr_lex->value , ".data") ) return DATA;
    else if ( strcmp( curr_lex->value , ".bss") )  return BSS;

    /* Dans l'énoncé (page 10) il est dit que :
        dans .text il n'y a que des instruction
        dans .data il n'y a que des directives de données
        dans .bss il n'y a que la directive .space
    */

    if (curr_section==TEXT) {
        if (curr_lex->lex_type==SYMBOLE) {
            if // curr_list_lex->next!=NULL  {
                if ( curr_list_lex->next-> (LEXEM) element->lex_type!=DEUX_PTS ) {  //alors c'est une instruction => counter+4
                    *decal_line += 4;
                }
            }
        }
    }

    else if (curr_section==DATA) {


    }


    else if (curr_section==BSS) {
        if (curr_lex->lex_type==DIRECTIVE) {
            if // curr_list_lex->next!=NULL  {
                if ( curr_list_lex->next-> (LEXEM) element->value ) ) {  //alors c'est une instruction => counter+4
                    *decal_line += 4;
                }
            }

        }

    }



    if ( strcmp( curr_lex->value, "\\n") ) {
        if      (curr_section==TEXT) *text_counter += *decal_line;
        else if (curr_section==DATA) *data_counter += *decal_line;
        else if (curr_section==BSS)  *bss_counter  += *decal_line;
    }



    //pas compter les comm
    return curr_section;
}
